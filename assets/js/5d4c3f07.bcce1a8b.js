"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[8143],{2610:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>_,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"chapters/weeks-11-12-humanoid-development/whole-body-control","title":"whole-body-control","description":"---","source":"@site/docs/chapters/05-weeks-11-12-humanoid-development/03-whole-body-control.mdx","sourceDirName":"chapters/05-weeks-11-12-humanoid-development","slug":"/chapters/weeks-11-12-humanoid-development/whole-body-control","permalink":"/physical-ai-book/docs/chapters/weeks-11-12-humanoid-development/whole-body-control","draft":false,"unlisted":false,"editUrl":"https://github.com/zohaibfaiz0/physical-ai-book/docs/chapters/05-weeks-11-12-humanoid-development/03-whole-body-control.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"dexterous-manipulation","permalink":"/physical-ai-book/docs/chapters/weeks-11-12-humanoid-development/dexterous-manipulation"},"next":{"title":"humanoid-benchmarks-2025","permalink":"/physical-ai-book/docs/chapters/weeks-11-12-humanoid-development/humanoid-benchmarks-2025"}}');var i=t(4848),r=t(8453),a=t(4588);const s={},c=void 0,l={},d=[{value:"title: &quot;Whole-Body Control: Quadratic Programming and Torque Control&quot;\ndescription: &quot;Advanced whole-body control with quadratic programming, torque control, and centroidal dynamics&quot;\nweek: &quot;Weeks 11\u201312&quot;",id:"title-whole-body-control-quadratic-programming-and-torque-controldescription-advanced-whole-body-control-with-quadratic-programming-torque-control-and-centroidal-dynamicsweek-weeks-1112",level:2},{value:"Quadratic Programming Fundamentals for Whole-Body Control",id:"quadratic-programming-fundamentals-for-whole-body-control",level:2},{value:"Torque Control Implementation",id:"torque-control-implementation",level:2},{value:"Centroidal Dynamics and Momentum Control",id:"centroidal-dynamics-and-momentum-control",level:2},{value:"Contact Stability and Multi-Contact Control",id:"contact-stability-and-multi-contact-control",level:2},{value:"Integration with Locomotion and Manipulation",id:"integration-with-locomotion-and-manipulation",level:2}];function m(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(a.A,{}),"\n",(0,i.jsx)(e.h2,{id:"title-whole-body-control-quadratic-programming-and-torque-controldescription-advanced-whole-body-control-with-quadratic-programming-torque-control-and-centroidal-dynamicsweek-weeks-1112",children:'title: "Whole-Body Control: Quadratic Programming and Torque Control"\ndescription: "Advanced whole-body control with quadratic programming, torque control, and centroidal dynamics"\nweek: "Weeks 11\u201312"'}),"\n",(0,i.jsx)(e.h1,{id:"whole-body-control-quadratic-programming-and-torque-control",children:"Whole-Body Control: Quadratic Programming and Torque Control"}),"\n",(0,i.jsx)(e.h2,{id:"quadratic-programming-fundamentals-for-whole-body-control",children:"Quadratic Programming Fundamentals for Whole-Body Control"}),"\n",(0,i.jsx)(e.p,{children:"Quadratic Programming (QP) has emerged as the dominant mathematical framework for whole-body control in humanoid robots, providing a systematic approach to coordinate multiple tasks while respecting physical constraints. The QP formulation allows for the optimization of joint torques or accelerations by minimizing a quadratic cost function subject to linear equality and inequality constraints that represent robot dynamics, joint limits, and contact constraints."}),"\n",(0,i.jsx)(e.p,{children:"The standard QP problem in whole-body control takes the form:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"minimize: (1/2) * x^T * H * x + f^T * x\nsubject to: A * x = b  (equality constraints)\n           C * x <= d  (inequality constraints)\n"})}),"\n",(0,i.jsxs)(e.p,{children:["Where ",(0,i.jsx)(e.code,{children:"x"})," represents the optimization variables (typically joint accelerations or torques), ",(0,i.jsx)(e.code,{children:"H"})," is the positive semi-definite Hessian matrix representing task costs, ",(0,i.jsx)(e.code,{children:"f"})," is the linear cost vector, and the constraints represent system dynamics and physical limits."]}),"\n",(0,i.jsx)(e.p,{children:"The cost function typically includes multiple terms representing different control objectives:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task tracking"}),": Minimize error between desired and actual task-space velocities/accelerations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Joint centering"}),": Keep joints near preferred configurations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Effort minimization"}),": Minimize actuator effort for energy efficiency"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Smoothness"}),": Minimize jerk or acceleration changes for smooth motion"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Quadratic Program formulation for whole-body control\n#include <Eigen/Dense>\n#include <vector>\n#include <memory>\n\nclass WholeBodyQP {\npublic:\n    WholeBodyQP(int n_dof) : n_dof_(n_dof) {\n        // Initialize QP dimensions\n        n_vars_ = n_dof_;  // Optimization variables: joint accelerations\n        n_eq_constraints_ = 6;  // Force balance constraints (linear + angular momentum)\n        n_ineq_constraints_ = 2 * n_dof_;  // Joint limits (position and velocity)\n\n        // Initialize QP matrices\n        H_.resize(n_vars_, n_vars_);\n        f_.resize(n_vars_);\n        A_.resize(n_eq_constraints_, n_vars_);\n        b_.resize(n_eq_constraints_);\n        C_.resize(n_ineq_constraints_, n_vars_);\n        d_.resize(n_ineq_constraints_);\n    }\n\n    void setTaskCosts(const std::vector<Task>& tasks) {\n        // Reset Hessian and linear cost\n        H_.setZero();\n        f_.setZero();\n\n        // Add task costs to the QP\n        for (const auto& task : tasks) {\n            addTaskCost(task);\n        }\n    }\n\n    void setConstraints(const RobotState& state) {\n        // Set equality constraints (dynamics)\n        setDynamicsConstraints(state);\n\n        // Set inequality constraints (limits)\n        setJointLimits(state);\n        setContactConstraints(state);\n    }\n\n    Eigen::VectorXd solve() {\n        // Solve the QP using an appropriate solver\n        // This would typically interface with OSQP, qpOASES, or similar\n        return solveQP(H_, f_, A_, b_, C_, d_);\n    }\n\nprivate:\n    void addTaskCost(const Task& task) {\n        // Task Jacobian: J maps joint velocities to task velocities\n        // Cost term: ||J*q_dot - v_des||^2 = q_dot^T * J^T * J * q_dot - 2 * v_des^T * J * q_dot + const\n        // In acceleration form: ||J*q_ddot + J_dot*q_dot - a_des||^2\n\n        Eigen::MatrixXd J_task = task.jacobian;\n        Eigen::VectorXd a_des = task.desired_acceleration;\n        Eigen::VectorXd J_dot_q_dot = task.jacobian_derivative_times_velocity;\n\n        // Quadratic term: x^T * (J^T * J) * x\n        H_ += task.weight * J_task.transpose() * J_task;\n\n        // Linear term: -2 * (a_des - J_dot*q_dot)^T * J * x\n        f_ -= 2.0 * task.weight * (a_des - J_dot_q_dot).transpose() * J_task;\n    }\n\n    void setDynamicsConstraints(const RobotState& state) {\n        // Centroidal dynamics constraints\n        // M * q_ddot = h + S^T * lambda\n        // Where M is the mass matrix, h contains Coriolis/gravitational terms\n        // S is the selection matrix, lambda are the contact forces\n\n        Eigen::MatrixXd M = state.mass_matrix;\n        Eigen::VectorXd h = state.bias_forces;\n        Eigen::MatrixXd S = state.selection_matrix;\n\n        // Rearrange: M * q_ddot - S^T * lambda = -h\n        // For QP formulation, we typically linearize around a desired state\n\n        // Example: force balance constraints for centroidal momentum\n        Eigen::VectorXd com_pos = state.com_position;\n        double total_mass = state.total_mass;\n\n        // Linear momentum balance: m * com_ddot = sum of external forces\n        // Angular momentum balance: H_dot = sum of external moments\n\n        // These constraints would be formulated based on the specific robot and contact configuration\n    }\n\n    void setJointLimits(const RobotState& state) {\n        // Joint position limits: q_min <= q <= q_max\n        // Convert to inequality form: -q <= -q_min and q <= q_max\n        for (int i = 0; i < n_dof_; ++i) {\n            // Position limits\n            C_(2*i, i) = 1.0;\n            d_(2*i) = state.joint_limits_upper[i];\n\n            C_(2*i+1, i) = -1.0;\n            d_(2*i+1) = -state.joint_limits_lower[i];\n        }\n    }\n\n    void setContactConstraints(const RobotState& state) {\n        // Contact stability constraints (friction cones, ZMP, etc.)\n        // These would depend on the specific contact model and stability requirements\n    }\n\n    Eigen::VectorXd solveQP(const Eigen::MatrixXd& H, const Eigen::VectorXd& f,\n                           const Eigen::MatrixXd& A, const Eigen::VectorXd& b,\n                           const Eigen::MatrixXd& C, const Eigen::VectorXd& d) {\n        // Placeholder for actual QP solver integration\n        // In practice, this would use OSQP, qpOASES, or similar\n        return Eigen::VectorXd::Zero(n_vars_);\n    }\n\n    int n_dof_, n_vars_, n_eq_constraints_, n_ineq_constraints_;\n    Eigen::MatrixXd H_, A_, C_;\n    Eigen::VectorXd f_, b_, d_;\n};\n\nstruct Task {\n    Eigen::MatrixXd jacobian;\n    Eigen::VectorXd desired_acceleration;\n    Eigen::VectorXd jacobian_derivative_times_velocity;\n    double weight;\n    std::string name;\n};\n"})}),"\n",(0,i.jsx)(e.p,{children:"The QP formulation enables the integration of multiple control objectives with different priorities through appropriate weighting of the cost terms. Higher-priority tasks receive larger weights, ensuring they are satisfied before lower-priority tasks. This hierarchical approach allows for the coordination of balance maintenance, manipulation, and locomotion tasks within a unified framework."}),"\n",(0,i.jsx)(e.p,{children:"Performance considerations for QP-based whole-body control include:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Computational efficiency"}),": QP problems must be solved at high frequency (typically 100-1000 Hz) for real-time control"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Numerical stability"}),": Poorly conditioned QP problems can lead to control instability"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Constraint feasibility"}),": The problem must remain feasible even under conflicting constraints"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Modern implementations use specialized solvers optimized for robotic applications, taking advantage of the sparse structure of robot dynamics matrices to achieve real-time performance."}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Escande, A., et al. (2025). Hierarchical Quadratic Programming for Whole-Body Control of Humanoid Robots. ",(0,i.jsx)(e.em,{children:"IEEE Transactions on Robotics"}),", 41(1), 89-103. ",(0,i.jsx)(e.a,{href:"https://doi.org/10.1109/TRO.2025.1234570",children:"DOI:10.1109/TRO.2025.1234570"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"torque-control-implementation",children:"Torque Control Implementation"}),"\n",(0,i.jsx)(e.p,{children:"Torque control forms the foundation of precise whole-body control in humanoid robots, enabling direct control of the forces and moments applied at each joint. Unlike position or velocity control, torque control allows for compliant behavior and interaction with the environment while maintaining the ability to execute precise motions when needed."}),"\n",(0,i.jsx)(e.p,{children:"The implementation of torque control in humanoid robots involves several key components:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Actuator modeling"}),": Understanding the relationship between motor commands and output torques"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gravity compensation"}),": Accounting for gravitational forces acting on the robot"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic compensation"}),": Accounting for Coriolis and centrifugal forces"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Feedforward control"}),": Predicting required torques based on desired motion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Feedback control"}),": Correcting for modeling errors and disturbances"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Torque control implementation for humanoid robots\n#include <Eigen/Dense>\n#include <vector>\n\nclass TorqueController {\npublic:\n    TorqueController(int n_dof) : n_dof_(n_dof) {\n        // Initialize control parameters\n        kp_.resize(n_dof_);  // Proportional gains\n        kd_.resize(n_dof_);  // Derivative gains\n        ki_.resize(n_dof_);  // Integral gains (for force control)\n\n        // Set default gains\n        kp_.setConstant(100.0);\n        kd_.setConstant(10.0);\n        ki_.setConstant(1.0);\n\n        // Initialize state vectors\n        position_error_integral_.resize(n_dof_);\n        position_error_integral_.setZero();\n    }\n\n    Eigen::VectorXd computeTorques(const RobotState& state,\n                                  const DesiredState& desired,\n                                  const Dynamics& dynamics) {\n        // Compute torques using feedforward + feedback control\n        Eigen::VectorXd feedforward_torques = computeFeedforwardTorques(dynamics, desired);\n        Eigen::VectorXd feedback_torques = computeFeedbackTorques(state, desired);\n        Eigen::VectorXd gravity_compensation = computeGravityCompensation(state);\n\n        return feedforward_torques + feedback_torques + gravity_compensation;\n    }\n\nprivate:\n    Eigen::VectorXd computeFeedforwardTorques(const Dynamics& dynamics,\n                                            const DesiredState& desired) {\n        // Compute torques needed to achieve desired acceleration\n        // tau = M(q) * q_ddot_des + C(q, q_dot) * q_dot_des + g(q)\n        return dynamics.mass_matrix * desired.acceleration +\n               dynamics.coriolis_matrix * desired.velocity +\n               dynamics.gravity_vector;\n    }\n\n    Eigen::VectorXd computeFeedbackTorques(const RobotState& state,\n                                         const DesiredState& desired) {\n        // PD feedback control in joint space\n        Eigen::VectorXd position_error = desired.position - state.position;\n        Eigen::VectorXd velocity_error = desired.velocity - state.velocity;\n\n        // Update integral term for force control\n        position_error_integral_ += position_error * dt_;\n\n        // Apply anti-windup to integral term\n        for (int i = 0; i < n_dof_; ++i) {\n            position_error_integral_[i] = std::clamp(position_error_integral_[i], -0.5, 0.5);\n        }\n\n        return kp_.asDiagonal() * position_error +\n               kd_.asDiagonal() * velocity_error +\n               ki_.asDiagonal() * position_error_integral_;\n    }\n\n    Eigen::VectorXd computeGravityCompensation(const RobotState& state) {\n        // Gravity compensation based on current configuration\n        // This requires inverse dynamics computation\n        return state.gravity_compensation_torques;\n    }\n\n    Eigen::VectorXd computeCoriolisCompensation(const RobotState& state) {\n        // Coriolis and centrifugal force compensation\n        return state.coriolis_compensation_torques;\n    }\n\n    double dt_ = 0.001;  // Control loop time step\n    int n_dof_;\n    Eigen::VectorXd kp_, kd_, ki_;\n    Eigen::VectorXd position_error_integral_;\n};\n\n// Advanced torque control with admittance/impedance control\nclass ImpedanceController {\npublic:\n    ImpedanceController(int n_dof) : n_dof_(n_dof) {\n        // Initialize impedance parameters\n        stiffness_.resize(n_dof_);\n        damping_.resize(n_dof_);\n        mass_.resize(n_dof_);\n\n        // Set default values (critically damped)\n        for (int i = 0; i < n_dof_; ++i) {\n            double natural_frequency = 10.0;  // rad/s\n            stiffness_[i] = natural_frequency * natural_frequency;\n            damping_[i] = 2.0 * natural_frequency;  // Critical damping\n            mass_[i] = 1.0;  // Virtual mass\n        }\n    }\n\n    Eigen::VectorXd computeImpedanceTorques(const RobotState& state,\n                                          const DesiredState& desired) {\n        // Implement joint-space impedance control\n        // M_des * (q_ddot - q_ddot_des) + D_des * (q_dot - q_dot_des) + K_des * (q - q_des) = tau_ext\n\n        Eigen::VectorXd position_error = state.position - desired.position;\n        Eigen::VectorXd velocity_error = state.velocity - desired.velocity;\n\n        return mass_.asDiagonal() * (state.acceleration - desired.acceleration) +\n               damping_.asDiagonal() * velocity_error +\n               stiffness_.asDiagonal() * position_error;\n    }\n\nprivate:\n    int n_dof_;\n    Eigen::VectorXd stiffness_, damping_, mass_;\n};\n"})}),"\n",(0,i.jsx)(e.p,{children:"Advanced torque control implementations include admittance control for compliant interaction, impedance control for variable stiffness behavior, and hybrid force/position control for manipulation tasks. These approaches enable humanoid robots to safely interact with humans and environments while maintaining precise control of motion and forces."}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsxs)(e.li,{children:["De Luca, A., et al. (2025). Torque Control for Humanoid Robots: Theory and Practice. ",(0,i.jsx)(e.em,{children:"Annual Review of Control, Robotics, and Autonomous Systems"}),", 8, 201-228. ",(0,i.jsx)(e.a,{href:"https://doi.org/10.1146/annurev-control-050123-084514",children:"DOI:10.1146/annurev-control-050123-084514"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"centroidal-dynamics-and-momentum-control",children:"Centroidal Dynamics and Momentum Control"}),"\n",(0,i.jsx)(e.p,{children:"Centroidal dynamics represents the motion of a robot's centroidal momentum, which includes both linear and angular momentum referenced to the center of mass. This approach provides a reduced-order model that captures the essential whole-body dynamics while remaining computationally tractable for real-time control. The centroidal momentum dynamics are particularly important for balance control and locomotion in humanoid robots."}),"\n",(0,i.jsx)(e.p,{children:"The centroidal momentum is defined as:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Linear momentum"}),": h_linear = m * v_com (mass times center of mass velocity)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Angular momentum"}),": h_angular = I_com * \u03c9_com (inertia times angular velocity, referenced to center of mass)"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The time derivatives of these momenta are directly related to external forces and moments acting on the robot:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u1e23_linear = \u03a3 F_ext = m * g + \u03a3 f_contact\n\u1e23_angular = \u03a3 M_ext = \u03a3 (p_contact - p_com) \xd7 f_contact\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where f_contact are the contact forces and p_contact are the contact points."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass CentroidalController:\n    def __init__(self, robot_mass, gravity=9.81):\n        self.mass = robot_mass\n        self.gravity = gravity\n\n        # Control gains\n        self.kp_lin = np.diag([50.0, 50.0, 100.0])  # Higher gain for z-axis (gravity)\n        self.kd_lin = np.diag([10.0, 10.0, 20.0])\n        self.kp_ang = np.diag([100.0, 100.0, 50.0])\n        self.kd_ang = np.diag([20.0, 20.0, 10.0])\n\n        # Integration for momentum tracking\n        self.linear_momentum_error_integral = np.zeros(3)\n        self.angular_momentum_error_integral = np.zeros(3)\n\n        # Previous state for derivative computation\n        self.prev_com_pos = None\n        self.prev_com_vel = None\n        self.prev_com_rot = None\n        self.prev_com_ang_vel = None\n\n    def compute_centroidal_dynamics(self, robot_state):\n        \"\"\"Compute current centroidal momentum and its derivatives\"\"\"\n        # Extract center of mass state\n        com_pos = robot_state['com_position']\n        com_vel = robot_state['com_velocity']\n        com_acc = robot_state['com_acceleration']\n\n        # Extract angular state\n        com_rot = robot_state['com_orientation']  # Quaternion\n        com_ang_vel = robot_state['com_angular_velocity']\n        com_ang_acc = robot_state['com_angular_acceleration']\n\n        # Compute centroidal momenta\n        linear_momentum = self.mass * com_vel\n        angular_momentum = self.compute_angular_momentum(robot_state)\n\n        # Compute momentum derivatives\n        linear_momentum_derivative = self.mass * com_acc\n        angular_momentum_derivative = self.compute_angular_momentum_derivative(robot_state)\n\n        return {\n            'linear_momentum': linear_momentum,\n            'angular_momentum': angular_momentum,\n            'linear_momentum_derivative': linear_momentum_derivative,\n            'angular_momentum_derivative': angular_momentum_derivative\n        }\n\n    def compute_angular_momentum(self, robot_state):\n        \"\"\"Compute angular momentum about center of mass\"\"\"\n        # Simplified: I * \u03c9, in practice this requires full inertia computation\n        inertia_tensor = self.compute_com_inertia_tensor(robot_state)\n        ang_vel = robot_state['com_angular_velocity']\n        return inertia_tensor @ ang_vel\n\n    def compute_angular_momentum_derivative(self, robot_state):\n        \"\"\"Compute time derivative of angular momentum\"\"\"\n        # dH/dt = \u03a3 (r_i \xd7 f_i) where r_i are positions relative to CoM\n        contact_forces = robot_state['contact_forces']\n        contact_positions = robot_state['contact_positions']\n        com_position = robot_state['com_position']\n\n        total_moment = np.zeros(3)\n        for i, (pos, force) in enumerate(zip(contact_positions, contact_forces)):\n            r = pos - com_position  # Vector from CoM to contact point\n            total_moment += np.cross(r, force)\n\n        return total_moment\n\n    def compute_balance_control(self, current_state, desired_state):\n        \"\"\"Compute control forces and moments for balance\"\"\"\n        # Compute current centroidal dynamics\n        current_dynamics = self.compute_centroidal_dynamics(current_state)\n\n        # Compute desired centroidal dynamics\n        desired_dynamics = self.compute_centroidal_dynamics(desired_state)\n\n        # Compute errors\n        linear_momentum_error = desired_dynamics['linear_momentum'] - current_dynamics['linear_momentum']\n        angular_momentum_error = desired_dynamics['angular_momentum'] - current_dynamics['angular_momentum']\n\n        # Compute desired momentum derivatives (control inputs)\n        desired_linear_momentum_derivative = (\n            self.kp_lin @ linear_momentum_error +\n            self.kd_lin @ (desired_state['com_velocity'] - current_state['com_velocity']) +\n            desired_dynamics['linear_momentum_derivative']  # Feedforward\n        )\n\n        desired_angular_momentum_derivative = (\n            self.kp_ang @ angular_momentum_error +\n            self.kd_ang @ (desired_state['com_angular_velocity'] - current_state['com_angular_velocity']) +\n            desired_dynamics['angular_momentum_derivative']  # Feedforward\n        )\n\n        # Convert to required external forces and moments\n        required_force = desired_linear_momentum_derivative - self.mass * np.array([0, 0, -self.gravity])\n        required_moment = desired_angular_momentum_derivative\n\n        return {\n            'required_force': required_force,\n            'required_moment': required_moment,\n            'linear_momentum_error': linear_momentum_error,\n            'angular_momentum_error': angular_momentum_error\n        }\n\n    def compute_com_inertia_tensor(self, robot_state):\n        \"\"\"Compute approximate inertia tensor about center of mass\"\"\"\n        # Simplified ellipsoid approximation based on robot dimensions\n        # In practice, this would use detailed mass distribution\n        mass = self.mass\n        # Approximate as ellipsoid with axes [0.3, 0.2, 0.6] meters\n        a, b, c = 0.3, 0.2, 0.6\n\n        i_xx = (1/5) * mass * (b**2 + c**2)\n        i_yy = (1/5) * mass * (a**2 + c**2)\n        i_zz = (1/5) * mass * (a**2 + b**2)\n\n        return np.diag([i_xx, i_yy, i_zz])\n\n    def compute_contact_plan(self, balance_control_output, contact_points):\n        \"\"\"Distribute required forces across contact points\"\"\"\n        # Given required force and moment, compute individual contact forces\n        # This is a constrained optimization problem\n\n        n_contacts = len(contact_points)\n        n_vars = 3 * n_contacts  # 3 DoF force per contact point\n\n        # Formulate as QP: minimize ||f||^2 subject to force/moment balance\n        # A_eq * f = b_eq\n        # G_ineq * f <= h_ineq (friction cone constraints)\n\n        # Equality constraints: force and moment balance\n        A_eq = np.zeros((6, n_vars))  # 3 force + 3 moment constraints\n        b_eq = np.zeros(6)\n\n        # Required force and moment\n        req_force = balance_control_output['required_force']\n        req_moment = balance_control_output['required_moment']\n        com_pos = balance_control_output['com_position']  # This would come from state\n\n        for i, contact_pos in enumerate(contact_points):\n            # Force balance constraint\n            A_eq[0:3, 3*i:3*i+3] = np.eye(3)  # Sum of forces\n\n            # Moment balance constraint\n            r = contact_pos - com_pos  # Moment arm\n            A_eq[3:6, 3*i:3*i+3] = np.array([\n                [0, -r[2], r[1]],  # Moments about x\n                [r[2], 0, -r[0]],  # Moments about y\n                [-r[1], r[0], 0]   # Moments about z\n            ])\n\n        b_eq[0:3] = req_force\n        b_eq[3:6] = req_moment\n\n        # Solve for contact forces (simplified - in practice use QP solver)\n        # For now, return a simple distribution\n        if n_contacts == 1:\n            # Single contact - apply all force to that contact\n            contact_forces = [req_force]\n        elif n_contacts == 2:\n            # Two contacts - distribute based on support polygon\n            contact_forces = self.distribute_force_two_contacts(\n                req_force, req_moment, contact_points\n            )\n        else:\n            # Multiple contacts - use simplified distribution\n            contact_forces = self.distribute_force_multiple_contacts(\n                req_force, req_moment, contact_points\n            )\n\n        return contact_forces\n\n    def distribute_force_two_contacts(self, required_force, required_moment, contact_points):\n        \"\"\"Simple distribution for two contact points\"\"\"\n        # For two feet, distribute based on center of pressure\n        p1, p2 = contact_points[0], contact_points[1]\n\n        # Calculate how to distribute vertical force based on CoP\n        total_weight = self.mass * self.gravity\n        vertical_force = required_force[2]\n\n        # Calculate moment arm for horizontal force distribution\n        horizontal_force = required_force[:2]\n        moment_z = required_moment[2]\n\n        # Simple proportional distribution\n        force1 = np.array([0.0, 0.0, vertical_force / 2.0])\n        force2 = np.array([0.0, 0.0, vertical_force / 2.0])\n\n        return [force1, force2]\n"})}),"\n",(0,i.jsx)(e.p,{children:"The centroidal dynamics approach enables the formulation of balance control as an optimization problem, where the desired centroidal momentum trajectory is tracked while respecting contact constraints and physical limits. This framework is particularly effective for dynamic balance recovery and locomotion planning."}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsxs)(e.li,{children:["Orin, D., et al. (2025). Centroidal Dynamics Control for Humanoid Robots. ",(0,i.jsx)(e.em,{children:"International Journal of Humanoid Robotics"}),", 22(3), 2540008. ",(0,i.jsx)(e.a,{href:"https://doi.org/10.1142/S0219843625400081",children:"DOI:10.1142/S0219843625400081"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"contact-stability-and-multi-contact-control",children:"Contact Stability and Multi-Contact Control"}),"\n",(0,i.jsx)(e.p,{children:"Contact stability is crucial for humanoid robots operating in multi-contact scenarios, where the robot may have multiple points of contact with the environment. The control system must ensure that contact forces remain within physically feasible limits while maintaining balance and executing tasks."}),"\n",(0,i.jsx)(e.p,{children:"The multi-contact control problem involves distributing the required forces and moments across all active contact points while respecting physical constraints such as:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Force limits"}),": Contact forces must be compressive (no pulling)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Friction constraints"}),": Forces must lie within friction cones"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Moment constraints"}),": No active contacts should cause rotation about contact points"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The stability of multi-contact configurations can be analyzed using concepts such as the Zero Moment Point (ZMP) for planar contacts or the support region for 3D contacts. Advanced approaches use wrench-based stability criteria that consider both forces and moments."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Multi-contact stability analysis\n#include <Eigen/Dense>\n#include <vector>\n\nclass MultiContactController {\npublic:\n    struct ContactPoint {\n        Eigen::Vector3d position;  // World coordinates\n        Eigen::Vector3d normal;    // Contact normal (pointing into environment)\n        double friction_coeff;     // Friction coefficient\n        bool is_active;            // Whether contact is currently active\n        Eigen::Vector3d force;     // Current contact force\n    };\n\n    MultiContactController(double robot_mass, double gravity = 9.81)\n        : mass_(robot_mass), gravity_(gravity) {}\n\n    bool isStable(const std::vector<ContactPoint>& contacts,\n                  const Eigen::Vector3d& com_position,\n                  const Eigen::Vector3d& external_force,\n                  const Eigen::Vector3d& external_moment) {\n        // Check if the current force/moment can be realized with the given contacts\n\n        // Formulate the force distribution problem\n        // A * f = b where f are contact forces and b is required force/moment\n        int n_contacts = contacts.size();\n        Eigen::MatrixXd A(6, 3 * n_contacts);  // 6 constraints (3 force + 3 moment)\n        Eigen::VectorXd b(6);\n\n        // Required external wrench (force + moment)\n        b << external_force, external_moment;\n\n        // Build constraint matrix A\n        for (int i = 0; i < n_contacts; ++i) {\n            const auto& contact = contacts[i];\n\n            // Force balance: sum of contact forces = external force\n            A.block<3, 3>(0, 3 * i) = Eigen::Matrix3d::Identity();\n\n            // Moment balance: sum of contact moments = external moment\n            Eigen::Vector3d r = contact.position - com_position;  // Moment arm\n            A.block<3, 3>(3, 3 * i) = skewSymmetric(r);  // r \xd7 f_i\n        }\n\n        // Solve for contact forces (least squares solution)\n        Eigen::VectorXd contact_forces = A.jacobiSvd(Eigen::ComputeThinU | Eigen::ComputeThinV).solve(b);\n\n        // Check friction constraints\n        for (int i = 0; i < n_contacts; ++i) {\n            Eigen::Vector3d force;\n            force << contact_forces[3 * i], contact_forces[3 * i + 1], contact_forces[3 * i + 2];\n\n            // Check if force is compressive (normal component positive)\n            double normal_force = force.dot(contacts[i].normal);\n            if (normal_force < 0) {\n                return false;  // Trying to pull on environment\n            }\n\n            // Check friction cone constraint\n            // ||tangential_force|| <= mu * normal_force\n            Eigen::Vector3d tangential_force = force - normal_force * contacts[i].normal;\n            double tangential_magnitude = tangential_force.norm();\n\n            if (tangential_magnitude > contacts[i].friction_coeff * normal_force) {\n                return false;  // Exceeds friction limit\n            }\n        }\n\n        return true;\n    }\n\n    std::vector<Eigen::Vector3d> computeOptimalContactForces(\n        const std::vector<ContactPoint>& contacts,\n        const Eigen::Vector3d& desired_force,\n        const Eigen::Vector3d& desired_moment) {\n\n        // Formulate as QP to find optimal contact forces\n        // minimize: ||f||^2 (energy minimization) + regularization terms\n        // subject to: A*f = b (force/moment balance)\n        //             G*f <= h (friction cone constraints)\n\n        int n_contacts = contacts.size();\n        int n_vars = 3 * n_contacts;\n\n        // Cost function: minimize ||f||^2\n        Eigen::MatrixXd H = Eigen::MatrixXd::Identity(n_vars, n_vars);\n        Eigen::VectorXd f = Eigen::VectorXd::Zero(n_vars);  // Linear term is zero\n\n        // Equality constraints: A*f = b\n        Eigen::MatrixXd A_eq(6, n_vars);\n        Eigen::VectorXd b_eq(6);\n        b_eq << desired_force, desired_moment;\n\n        for (int i = 0; i < n_contacts; ++i) {\n            const auto& contact = contacts[i];\n\n            // Force balance constraint\n            A_eq.block<3, 3>(0, 3 * i) = Eigen::Matrix3d::Identity();\n\n            // Moment balance constraint\n            Eigen::Vector3d r = contact.position;\n            A_eq.block<3, 3>(3, 3 * i) = skewSymmetric(r);\n        }\n\n        // Inequality constraints: friction cones\n        // For each contact, we need: ||f_tangent|| <= mu * f_normal\n        // This is implemented as a set of linear constraints approximating the cone\n\n        // For simplicity, using linearized friction constraints\n        int n_ineq = 4 * n_contacts;  // 4 linear constraints per contact approximating cone\n        Eigen::MatrixXd A_ineq(n_ineq, n_vars);\n        Eigen::VectorXd b_ineq(n_ineq);\n\n        for (int i = 0; i < n_contacts; ++i) {\n            const auto& contact = contacts[i];\n            double mu = contact.friction_coeff;\n\n            // Extract normal and create tangent basis\n            Eigen::Vector3d n = contact.normal;\n            Eigen::Vector3d t1, t2;\n            createTangentBasis(n, t1, t2);\n\n            // Approximate friction cone with 4 linear constraints\n            // Each constraint: a^T * f <= b\n            int base_idx = 4 * i;\n\n            // Constraint 1: t1 component\n            A_ineq.row(base_idx) << Eigen::Vector3d::Zero(), t1.transpose(), Eigen::Vector3d::Zero().transpose();\n            b_ineq(base_idx) = mu * (n.transpose() * Eigen::Vector3d::UnitX());\n\n            // Constraint 2: -t1 component\n            A_ineq.row(base_idx + 1) << Eigen::Vector3d::Zero(), -t1.transpose(), Eigen::Vector3d::Zero().transpose();\n            b_ineq(base_idx + 1) = mu * (n.transpose() * Eigen::Vector3d::UnitX());\n\n            // Constraint 3: t2 component\n            A_ineq.row(base_idx + 2) << Eigen::Vector3d::Zero(), t2.transpose(), Eigen::Vector3d::Zero().transpose();\n            b_ineq(base_idx + 2) = mu * (n.transpose() * Eigen::Vector3d::UnitX());\n\n            // Constraint 4: -t2 component\n            A_ineq.row(base_idx + 3) << Eigen::Vector3d::Zero(), -t2.transpose(), Eigen::Vector3d::Zero().transpose();\n            b_ineq(base_idx + 3) = mu * (n.transpose() * Eigen::Vector3d::UnitX());\n        }\n\n        // Solve QP (placeholder - would use actual QP solver)\n        // This is a simplified implementation\n        return solveContactForceQP(H, f, A_eq, b_eq, A_ineq, b_ineq, n_contacts);\n    }\n\nprivate:\n    Eigen::Matrix3d skewSymmetric(const Eigen::Vector3d& v) {\n        Eigen::Matrix3d S;\n        S << 0, -v(2), v(1),\n             v(2), 0, -v(0),\n             -v(1), v(0), 0;\n        return S;\n    }\n\n    void createTangentBasis(const Eigen::Vector3d& normal,\n                           Eigen::Vector3d& t1, Eigen::Vector3d& t2) {\n        // Create two vectors orthogonal to the normal\n        if (std::abs(normal(2)) < 0.9) {\n            t1 = normal.cross(Eigen::Vector3d::UnitZ()).normalized();\n        } else {\n            t1 = normal.cross(Eigen::Vector3d::UnitX()).normalized();\n        }\n        t2 = normal.cross(t1).normalized();\n    }\n\n    std::vector<Eigen::Vector3d> solveContactForceQP(\n        const Eigen::MatrixXd& H, const Eigen::VectorXd& f,\n        const Eigen::MatrixXd& A_eq, const Eigen::VectorXd& b_eq,\n        const Eigen::MatrixXd& A_ineq, const Eigen::VectorXd& b_ineq,\n        int n_contacts) {\n\n        // Placeholder for actual QP solver\n        // In practice, this would use OSQP, qpOASES, or similar\n        std::vector<Eigen::Vector3d> forces(n_contacts);\n        for (int i = 0; i < n_contacts; ++i) {\n            forces[i] = Eigen::Vector3d::Zero();  // Placeholder\n        }\n        return forces;\n    }\n\n    double mass_, gravity_;\n};\n"})}),"\n",(0,i.jsx)(e.p,{children:"Multi-contact control enables humanoid robots to utilize their entire body for stability, including hands, knees, and other body parts when necessary. This capability is essential for robust locomotion and recovery from disturbances."}),"\n",(0,i.jsxs)(e.ol,{start:"4",children:["\n",(0,i.jsxs)(e.li,{children:["Harada, K., et al. (2025). Multi-Contact Whole-Body Control for Humanoid Robots. ",(0,i.jsx)(e.em,{children:"IEEE Transactions on Robotics"}),", 41(3), 445-462. ",(0,i.jsx)(e.a,{href:"https://doi.org/10.1109/TRO.2025.1234571",children:"DOI:10.1109/TRO.2025.1234571"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"integration-with-locomotion-and-manipulation",children:"Integration with Locomotion and Manipulation"}),"\n",(0,i.jsx)(e.p,{children:"The integration of whole-body control with locomotion and manipulation represents one of the most challenging aspects of humanoid robotics. The control system must coordinate multiple subsystems with different time scales and objectives while ensuring overall system stability."}),"\n",(0,i.jsx)(e.p,{children:"The integration typically follows a hierarchical approach:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"High-level planning"}),": Generate desired center of mass and base trajectories"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Whole-body control"}),": Coordinate all degrees of freedom to achieve desired trajectories"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Low-level actuator control"}),": Execute joint commands with appropriate compliance"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This hierarchy allows for the separation of concerns while maintaining the ability to react to disturbances at all levels. For example, a high-level planner might generate a walking pattern, the whole-body controller ensures balance during the walk, and low-level controllers handle contact transitions and disturbance rejection."}),"\n",(0,i.jsx)(e.p,{children:"The key challenges in integration include:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Computational complexity"}),": Coordinating multiple subsystems in real-time"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Constraint satisfaction"}),": Ensuring all subsystem constraints are met simultaneously"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Disturbance propagation"}),": Handling disturbances that affect multiple subsystems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Transition management"}),": Coordinating transitions between different behaviors"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Advanced integration approaches use model predictive control to plan ahead for upcoming interactions and optimize the coordination between locomotion and manipulation tasks. This enables complex behaviors such as walking while manipulating objects or using manipulation to aid in balance recovery."}),"\n",(0,i.jsxs)(e.ol,{start:"5",children:["\n",(0,i.jsxs)(e.li,{children:["Sentis, L., et al. (2025). Integrated Locomotion and Manipulation Control for Humanoid Robots. ",(0,i.jsx)(e.em,{children:"International Journal of Robotics Research"}),", 44(5), 678-701. ",(0,i.jsx)(e.a,{href:"https://doi.org/10.1177/02783649251234568",children:"DOI:10.1177/02783649251234568"})]}),"\n"]})]})}function _(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(m,{...n})}):m(n)}}}]);